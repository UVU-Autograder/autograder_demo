{
  "title": "Merge Sort Implementation",
  "language": "python",
  "description": "Implement efficient divide-and-conquer merge sort with O(n log n) complexity.",
  "instructions": "# Merge Sort Implementation\n\n## Problem Statement\n\nImplement the **merge sort** algorithm using divide-and-conquer. Merge sort is an efficient, stable sorting algorithm with guaranteed O(n log n) time complexity.\n\n### Algorithm Description\n\nMerge sort follows divide-and-conquer:\n1. **Divide**: Split the array into two halves\n2. **Conquer**: Recursively sort both halves\n3. **Combine**: Merge the two sorted halves\n\n## Visual Example\n\n**Input:** `[38, 27, 43, 3, 9]`\n\n```\n         [38, 27, 43, 3, 9]\n              /        \\\n      [38, 27, 43]   [3, 9]\n        /     \\        /   \\\n    [38, 27] [43]   [3]   [9]\n     /   \\     |     |     |\n   [38] [27] [43]   [3]   [9]\n     \\   /     |     |     |\n   [27, 38] [43]   [3]   [9]\n       \\    /        \\   /\n    [27, 38, 43]    [3, 9]\n           \\        /\n      [3, 9, 27, 38, 43]\n```\n\n**Output:** `[3, 9, 27, 38, 43]`\n\n## Test Cases\n\n```python\nmerge_sort([38, 27, 43, 3, 9])  # Expected: [3, 9, 27, 38, 43]\nmerge_sort([5, 4, 3, 2, 1])     # Expected: [1, 2, 3, 4, 5]\nmerge_sort([1, 2, 3, 4, 5])     # Expected: [1, 2, 3, 4, 5]\nmerge_sort([5, 2, 8, 2, 9])     # Expected: [2, 2, 5, 8, 9]\n```\n\n## Implementation Requirements\n\nYou need two functions:\n\n### merge_sort(arr)\n1. **Base case**: If array has ≤1 element, return it\n2. **Find middle**: Calculate midpoint\n3. **Divide**: Split into left and right halves\n4. **Recursively sort**: Sort both halves\n5. **Merge**: Combine sorted halves\n\n### merge(left, right)\n1. Create result array\n2. Compare elements from left and right\n3. Add smaller element to result\n4. Repeat until one array is empty\n5. Add remaining elements\n\n## Pseudocode\n\n```\nfunction merge_sort(arr):\n    if length(arr) <= 1:\n        return arr\n    mid = length(arr) // 2\n    left = merge_sort(arr[0:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\nfunction merge(left, right):\n    result = []\n    i = 0, j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n```\n\n## Performance\n\n| Metric | Value |\n|--------|-------|\n| **Time** | O(n log n) - Always |\n| **Space** | O(n) - Requires extra space |\n| **Stable** | Yes |\n\n### Why O(n log n)?\n- **Dividing**: log n levels (binary split)\n- **Merging**: n comparisons per level\n- **Total**: n × log n operations\n\n## Grading Rubric (100 points)\n\n- **Correctness (40 pts)**: Sorts all test cases\n- **Algorithm (35 pts)**: Proper divide-and-conquer with merge\n- **Code Quality (15 pts)**: Clean, readable\n- **Documentation (10 pts)**: Docstrings\n",
  "starterCode": "from typing import List\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list using merge sort (divide and conquer).\n    \n    Args:\n        arr: List of integers to sort\n        \n    Returns:\n        Sorted list in ascending order\n    \"\"\"\n    # TODO: Base case - array with 0 or 1 element\n    if len(arr) <= 1:\n        return arr\n    \n    # TODO: Find middle and divide\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # TODO: Recursively sort both halves\n    left = merge_sort(left)\n    right = merge_sort(right)\n    \n    # TODO: Merge the sorted halves\n    return merge(left, right)\n\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"\n    Merge two sorted arrays into one sorted array.\n    \n    Args:\n        left: First sorted array\n        right: Second sorted array\n        \n    Returns:\n        Merged sorted array\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # TODO: Compare and merge\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # TODO: Add remaining elements\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# Test your implementation\nif __name__ == \"__main__\":\n    print(merge_sort([38, 27, 43, 3, 9]))\n    print(merge_sort([5, 4, 3, 2, 1]))\n",
  "testCases": [
    {
      "input": "[38, 27, 43, 3, 9]",
      "expectedOutput": "[3, 9, 27, 38, 43]",
      "hidden": false
    },
    {
      "input": "[5, 4, 3, 2, 1]",
      "expectedOutput": "[1, 2, 3, 4, 5]",
      "hidden": false
    },
    {
      "input": "[1, 2, 3, 4, 5]",
      "expectedOutput": "[1, 2, 3, 4, 5]",
      "hidden": false
    },
    {
      "input": "[5, 2, 8, 2, 9]",
      "expectedOutput": "[2, 2, 5, 8, 9]",
      "hidden": false
    }
  ],
  "rubric": {
    "correctness": {
      "points": 40,
      "description": "All test cases pass correctly"
    },
    "algorithmImplementation": {
      "points": 35,
      "description": "Proper divide-and-conquer with correct merge logic"
    },
    "codeQuality": {
      "points": 15,
      "description": "Clean, readable code"
    },
    "documentation": {
      "points": 10,
      "description": "Docstrings and comments"
    }
  },
  "maxScore": 100,
  "isSample": true,
  "tags": ["sorting", "merge-sort", "divide-conquer", "recursion", "advanced"]
}
